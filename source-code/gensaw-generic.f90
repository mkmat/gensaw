	program gensaw_algorithm

! (c) mk@mat.ethz.ch 10 feb 2021
! (c) mk@mat.ethz.ch 25 nov 2023 (revisions marked by revised 25 nov 2023)

! notes: 
! all parameters, anchoring conditions, probabilities, box sizes on file 
! N denotes the number of bonds
! unfolded coordinates throughout (folded for outside checks)
! added 25 april 2021: fn (output option fn)
! added 26 april 2021: seed option

       implicit none
       integer chains,N
       include 'inc.N'	! defines N,chains
       real*8  u(N,3),x(0:N,3)
       real*8  b,d,d2
       include 'inc.parameter'
       real*8  xlo,xhi,ylo,yhi,zlo,zhi,boxx,boxy,boxz
       include 'inc.box'
       real*8  anchor_x(3),anchor_u1(3)
       integer i,j,k,line,linet,roots
       integer id,chain,idbond
       common /comid/ id,chain,idbond
       real myrand
       real myrand2(2)
       integer resolution
       include 'inc.resolution'
       real*8 cumphi(resolution),cross(3)
       real*8 cosphi(resolution),sinphi(resolution)
       real*8 ctheta(resolution),stheta(resolution)
       common /comcs/ cosphi, sinphi, ctheta, stheta
       integer periodx,periody,periodz
       include 'inc.periodic' ! defines periodic
       integer outputformat
       real*8  fn(0:N)
       include 'inc.outputformat'
       logical debug
       parameter(debug=.true.)
       real*8 ulen2,ulen
       logical overlap,outside
       external overlap,outside
       character(len=20) :: outputfile
       integer erpenbeck_s,erpenbeck_f
       common /erpenbeck_wall/ erpenbeck_s,erpenbeck_f
       logical created
       integer max_s
       character(len=3) :: charperiod(3)
       common /track_max_s/ max_s
       real*8 tic,toc,total_tic,total_toc
       integer id1,id2,id3
       character(len=255) :: gensaw_arguments
       integer gensaw_len
       real*8  average_ee,error_ee
       common /ave_ee/ average_ee,error_ee

	call system('rm -f _created _ee')
	call init_seed
	average_ee = 0.D0
	error_ee   = 0.D0

	open(2,file='_perl_arguments'); rewind(2)
	read(2,'(A)') gensaw_arguments
	close(2)
	call erase_blank_from_string(gensaw_arguments,gensaw_len)

	open(2,file='inc.cumprob_phi')
	do i=1,resolution
	 read(2,*) cumphi(i)
	 cosphi(i)=cos(cumphi(i))
	 sinphi(i)=sin(cumphi(i))
	enddo
	close(2)

	open(2,file='inc.cumprob_ctheta')
        do i=1,resolution
         read(2,*) ctheta(i)
	 stheta(i) = dsqrt(1.D0-ctheta(i)**2)
	 if (dabs(stheta(i)).lt.1.D-5) stheta(i)=1.D-5
        enddo
        close(2)

	open(10,file='inc.anchors'); rewind(10)

	include 'inc.strategy'
	open(2,file='_used_f_s'); rewind(2)
	write(2,*) erpenbeck_f
	write(2,*) erpenbeck_s
	close(2)

	!print 100,'using s = ',erpenbeck_s
	!print 100,'using X = ',erpenbeck_f

! ------ header output file
	select case (outputformat)
	case (1) 				! xyz
	 outputfile='config.xyz'
	 open(11,file=outputfile); rewind(11)	
	case (2) 				! dump
	 outputfile='config.dump'
	 open(11,file=outputfile); rewind(11)
	 write(11,'(A)') 'ITEM: TIMESTEP (created at complexfluids.ethz.ch/gensaw)'
	 write(11,'(A)') '0'
	 write(11,'(A)') 'ITEM: NUMBER OF ATOMS'
	 write(11,'(I10)') chains*(N+1)
	 charperiod(1)='ff '; if (periodx.eq.1) charperiod(1)='pp '
         charperiod(2)='ff '; if (periody.eq.1) charperiod(2)='pp '
 	 charperiod(3)='ff '; if (periodz.eq.1) charperiod(3)='pp '
	 write(11,'(A)') 'ITEM: BOX BOUNDS '//charperiod(1)//charperiod(2)//charperiod(3)    ! (revised 25 nov 2023)
	 write(11,*) xlo,xhi
	 write(11,*) ylo,yhi
	 write(11,*) zlo,zhi
	 write(11,'(A)') 'ITEM: ATOMS id mol type xu yu zu'
	case (3) 				! Z1
	 outputfile='config.Z1'
	 open(11,file=outputfile); rewind(11)
	 write(11,*) chains
	 write(11,*) boxx,boxy,boxz
	 write(11,*) chains,'*',N+1	
	case (4) 				! d3D
	 outputfile='config.d3D'
	 open(11,file=outputfile); rewind(11)
	 densHIST = 0
	case (5) 				! ee
	 outputfile='config.ee'
	 open(11,file=outputfile); rewind(11)
	case (6) 				! mol2
	 outputfile='config.mol2'
	 open(11,file='.tmp_mol2_atom'); rewind(11)
	 write(11,'(A)') '@<TRIPOS>MOLECULE'
	 write(11,'(A)') 'https://www.complexfluids.ethz.ch/gensaw'
         write(11,601) chains*(N+1),chains*N,0,0,0
         write(11,'(A)') 'SMALL'
         write(11,'(A)') 'USER_CHARGES'
         write(11,'(A)') 'SAW'
         write(11,'(A)') '@<TRIPOS>ATOM'
	 open(12,file='.tmp_mol2_bond'); rewind(12)
	 write(12,'(A)') '@<TRIPOS>BOND'
	case (7) 				! fn
	 outputfile='config.fn'
	 open(11,file=outputfile); rewind(11)
	 fn=0.D0
	case (8) 				! gro
	 outputfile='config.gro'
	 open(11,file=outputfile); rewind(11)
	 write(11,'(A)') 'configuration generated by gensaw '//gensaw_arguments(1:gensaw_len)
	 write(11,*) chains*(N+1)
	case (9) 				! pdb
	 outputfile='config.pdb'
	 open(11,file=outputfile); rewind(11)
	 write(11,'(A6,A)') 'REMARK ',' configuration generated by gensaw '//gensaw_arguments(1:gensaw_len)
	 write(11,'(A6,1x,A,2F8.3)') 'REMARK ',' xlo xhi ',xlo,xhi
	 write(11,'(A6,1x,A,2F8.3)') 'REMARK ',' xlo xhi ',xlo,xhi
	 write(11,'(A6,1x,A,2F8.3)') 'REMARK ',' xlo xhi ',xlo,xhi
	 write(11,'(A6,3F9.3,3F7.2,1X,11A1,I4)') 'CRYST1',xhi-xlo,yhi-ylo,zhi-zlo
	end select
! -----------------

	id = 0
	chain = 0
	created = .true.
	roots = 0
	rewind(10)
	max_s = 0
	call mk_tictoc(tic)
	call mk_tictoc(total_tic)

	do while (chain.lt.chains)

	 if (created) then
303 	  continue
	  read(10,*,end=301) anchor_x,anchor_u1
	  roots = roots + 1
	  call mk_tictoc(tic)
	  goto 302
301 	  rewind(10); goto 303	  
302 	  continue
	 endif
	 call get_x012(anchor_x,anchor_u1,b,x,u)

	 created=.false.
	 call walk(x,u,3,created)

	 if (created) then
	  if (mod(chain,1+chains/20).eq.0) then
	   print 300,'created',chain,' chains ',nint(chain/dble(chains)*100),'% done'
300	   format(A7,1x,I6,A,I3,A)
	  endif
	 elseif (chain.le.chains/100) then
	  call mk_tictoc(toc)
	  if (toc.gt.tic+0.1+0.0001*N) then
	   if (erpenbeck_s.eq.1) then
	    erpenbeck_f=erpenbeck_f+1
	    print 100,'E-W using X s',erpenbeck_f,erpenbeck_s
	   else
	    erpenbeck_s = max(1,erpenbeck_s-1)
	   endif
	   print 100,'E-W using X s',erpenbeck_f,erpenbeck_s
	  endif
	 endif

        enddo

	call mk_tictoc(total_toc)
	print '(I8,1x,A)',roots,' roots used'
	print '(A)','now saving ..'

	select case (outputformat) 
	case (4) 			! d3D
	 do id1=1,densMX
	 do id2=1,densMY
	 do id3=1,densMZ
	  if (densHIST(id1,id2,id3).gt.0) then
	   write(11,114) xlo+(id1-0.5),ylo+(id2-0.5),zlo+(id3-0.5),densHIST(id1,id2,id3)
	  endif
	 enddo
	 enddo
	 enddo
	case (7) 			! fn
	 do i=0,N
	  write(11,*) i,fn(i)/fn(0)
	 enddo
	case (8) 			! gro
	 write(11,*) xhi-xlo,yhi-ylo,zhi-zlo
	end select

	close(11)
        close(12)

	select case (outputformat)
	case (6) 			! mol2
	 call execute_command_line('cat .tmp_mol2_atom .tmp_mol2_bond > '//outputfile)
	 call system('perl INSTDIR/gensaw-erase-blanks config.mol2')
	case (1) 			! xyz
	 call system('perl INSTDIR/gensaw-erase-blanks config.xyz')
	case (2) 			! dump
	 call system('perl INSTDIR/gensaw-erase-blanks config.dump')
	case (3) 			! Z1
	 call system('perl INSTDIR/gensaw-erase-blanks config.Z1')
	case (4) 			! d3D
	 call system('perl INSTDIR/gensaw-erase-blanks config.d3D')
	case (5) 			! ee
	 call system('perl INSTDIR/gensaw-erase-blanks config.ee')
	case (7) 			! fn
	 call system('perl INSTDIR/gensaw-erase-blanks config.fn')
	end select
	
        print '(A)','created: '//outputfile
	open(11,file='_created'); write(11,'(A)') outputfile; close(11)	

! ---------------------------------------------------------------------------------------------------

	print 101,'cpu secs',total_toc-total_tic
	print 101,'cpu microsecs/atom',1e6*(total_toc-total_tic)/dble(N*chains)
	open(44,file='_musecs_per_atom'); rewind(44); write(44,*) 1e6*(total_toc-total_tic)/dble(N*chains); close(44)

	average_ee = average_ee/dble(chains)
	error_ee   = error_ee/dble(chains)
	error_ee   = dsqrt((error_ee-average_ee**2)/dble(chains))
	print 101,'measured <R^2>',average_ee,' +/- ',error_ee
	open(11,file='_ee'); write (11,'(F16.5,/,F16.5)') average_ee,error_ee; close(11)

	include 'inc.format'
	call finalize_seed

100	format(A40,2(I10,1x))
101	format(A40,F12.6,A,F12.6)
	stop
	end

	subroutine optimize_erpenbeck_strategy_III
	implicit none
        integer chains,N
        include 'inc.N' ! defines N,chains
        real*8  x(0:N,3),u(N,3)
        real*8  anchor_x(3),anchor_u1(3)
        real*8  b,d,d2
        include 'inc.parameter'
        integer id,chain,idbond
        common /comid/ id,chain,idbond
        logical created
        integer i,j,k,jmax
        logical outside,overlap
        external outside,overlap
        integer hist(0:N+1)
        real*8  surv_prob(0:N+2)
        integer erpenbeck_s,erpenbeck_f
        common /erpenbeck_wall/ erpenbeck_s,erpenbeck_f
        logical EX
        integer sumhist,s1,s2,max_s
        real*8  max_surv_prob,p1,p2
	real*8  b_version_1,b_version_2,b_use
        integer inspect_chains
	 inspect_chains = max(10000,min(1+chains/2,100000))
	 do i=0,N+1; hist(i)=0; enddo
	 rewind(10)
         chain = 0
         max_s = 0
	 do while (chain.lt.inspect_chains)
          chain = chain + 1
          if (mod(chain+1,chains).eq.0) rewind(10)
303       continue
          read(10,*,end=301) anchor_x,anchor_u1
          call get_x012(anchor_x,anchor_u1,b,x,u)
          j=3
          jmax=0
          call linearwalk(x,u,j,jmax)
          hist(jmax) = hist(jmax) + 1
          max_s = max(max_s,jmax)
          goto 302
301       rewind(10); goto 303
302       continue
         enddo

	 print 100,'E-W inspect chains',inspect_chains
	 print 100,'E-W brute force last visited s',max_s
	 b_version_1 =  dlog(dble(inspect_chains)/dble(hist(max_s)))/dble(max_s-1)
	 print 101,'E-W b (vs1)',b_version_1

	 ! analyze hist, estimate p(N)
         sumhist = 0; do i=0,N; sumhist=sumhist+hist(i); enddo
         do i=0,N
          if (hist(i).gt.0) max_s=i
          surv_prob(i)=dble(hist(i))/dble(sumhist)
         enddo
         max_surv_prob = 0.D0
	 s1 = 1
         do i=0,N
          if (surv_prob(i).gt.max_surv_prob) then
           max_surv_prob = surv_prob(i)
           s1 = i
          endif
         enddo
         s2 = 0
         do i=0,N
          if (surv_prob(i).gt.max_surv_prob/10.0) then
           s2 = i
          endif
         enddo
         p2 = surv_prob(s2)
         if (2*s1.lt.s2-1.and.s1.lt.N/2) s1 = min(N,2*s1)
         p1 = surv_prob(s1)
         print 100,'E-W bound s1 =',s1
         print 100,'E-W bound s2 =',s2

         print 102,'E-W surv_prob s1 ',s1,surv_prob(s1)
         print 102,'E-W surv_prob s2 ',s2,surv_prob(s2)

         if (s1.ge.s2) then
          if (max_s.ge.N-2) then
           erpenbeck_f = 1
           erpenbeck_s = N
          else
           erpenbeck_f = 2
           erpenbeck_s = N/2
          endif
         else
          b_version_2 = dlog(p2/p1)/dble(s1-s2)    
	  print 101,'E-W b (vs2)',b_version_2
	  b_use       = max(0.D0,min(b_version_1,b_version_2))
	  print 101,'E-W b (use)',b_use
	  call ensure_unity(N,b_use,erpenbeck_f,erpenbeck_s)  
	 endif

	if (erpenbeck_s.eq.0) then
         erpenbeck_s = 1
         erpenbeck_f = 20             
        endif

	print 100,'E-W using X s',erpenbeck_f,erpenbeck_s

	rewind(10)
	call finalize_seed

100	format(A40,2(I10,1x))
101 	format(A40,F10.3)
102	format(A40,I10,1x,F10.6)	 

	return
	end

	subroutine optimize_erpenbeck_strategy_I
	implicit none
        integer chains,N
        include 'inc.N' ! defines N,chains
	real*8  b,d,d2
        include 'inc.parameter'
	integer id,chain,idbond
	common /comid/ id,chain,idbond
	logical created
	integer erpenbeck_s,erpenbeck_f
        common /erpenbeck_wall/ erpenbeck_s,erpenbeck_f
	integer roots,trialchains
	real*8 tic,cpu,timeout,bestcpu
	integer best_s,best_f

	 trialchains     = 5
	 timeout 	 = 0.001*N
	 bestcpu 	 = 1.D30
	 do erpenbeck_s  = 1,3
         do erpenbeck_f  = 1,6
	  rewind(10)
	  call mk_tictoc(tic)
 	  call get_chain_roots(trialchains,chain,roots,tic,timeout)
	  call mk_tictoc(cpu); cpu=cpu-tic
	  if (cpu.lt.bestcpu.and.chain.gt.0) then
	   bestcpu = cpu
	   timeout = bestcpu+0.1
	   best_s  = erpenbeck_s
	   best_f  = erpenbeck_f
	  endif
	  print 1,erpenbeck_s,erpenbeck_f,trialchains,chain,roots,cpu
1	  format("s f trialchains chains roots cpu ",5(I5,1x),F10.3)
	 enddo	 
	 enddo

	 erpenbeck_s = best_s
	 erpenbeck_f = best_f 
	 print '(A40,I10,1x,I10)','E-W using X s',erpenbeck_f,erpenbeck_s
	 rewind(10)
	 call finalize_seed
	return
	end

	subroutine get_chain_roots(trialchains,chain,roots,tic,timeout)
	implicit none
        integer chains,N
	include 'inc.N' ! defines N,chains
	real*8  x(0:N,3),u(N,3)
        real*8  b,d,d2
        include 'inc.parameter'
        logical created
        integer erpenbeck_s,erpenbeck_f
        common /erpenbeck_wall/ erpenbeck_s,erpenbeck_f
        integer chain,roots
	real*8  anchor_x(3),anchor_u1(3)
	integer k,trialchains
	real*8  tic,toc,timeout
	logical overlap,outside
	external overlap,outside
	 chain = 0
         created = .true.
         roots = 0
         do while (chain.lt.trialchains)
          if (created) then
           read(10,*) anchor_x,anchor_u1
           roots = roots + 1
          endif
	  call mk_tictoc(toc)
	  if (toc.gt.tic+timeout) return
	  call get_x012(anchor_x,anchor_u1,b,x,u)
          created=.false.
          call quickwalk(x,u,3,created,tic,timeout)
         enddo
	return
	end

        recursive subroutine quickwalk(x,u,j,created,tic,timeout)       ! j-1 is known generate j
        implicit none
        integer chains,N
        include 'inc.N' ! defines N,chains
        real*8  u(N,3),x(0:N,3)
        integer resolution
        include 'inc.resolution'
        real*8  b,d,d2
        include 'inc.parameter'
        real*8 cross(3),ulen,ulen2
        real*8 cosphi(resolution),sinphi(resolution)
	real*8 ctheta(resolution),stheta(resolution)
        common /comcs/ cosphi, sinphi, ctheta, stheta
        integer id,chain,idbond
        common /comid/ id,chain,idbond
        integer outputformat
        real*8 fn(0:N)
        include 'inc.outputformat'
        real myrand2(2)
        integer line,linet,i,j,k
        logical created
        logical overlap,outside
        external overlap,outside
        integer erpenbeck_s,erpenbeck_f
        common /erpenbeck_wall/ erpenbeck_s,erpenbeck_f
	real*8 unit(3),scalar
	real*8 tic,toc,timeout
	real*8 ctheta_prev,stheta_prev,prefactor,factor1,factor2,factor3,factor4
         created=.false.
	 call mk_tictoc(toc)
	 if (toc.gt.tic+timeout) return
         if (j.eq.N+1) then
          created=.true.
	  if (chain.eq.chains) return
          chain=chain+1
          return
         else
          call random_number(myrand2)
          line =1+int(resolution*myrand2(1))
	  linet=1+int(resolution*myrand2(2))
          cross(1) = u(j-2,2)*u(j-1,3)-u(j-2,3)*u(j-1,2)
          cross(2) = u(j-2,3)*u(j-1,1)-u(j-2,1)*u(j-1,3)
          cross(3) = u(j-2,1)*u(j-1,2)-u(j-2,2)*u(j-1,1)
	  ctheta_prev = u(j-2,1)*u(j-1,1)+u(j-2,2)*u(j-1,2)+u(j-2,3)*u(j-1,3)
          stheta_prev = dsqrt(1.D0-ctheta_prev**2)
	  if (stheta_prev.lt.1.D-6) then			! exception for u(j-2) || u(j-1) (find a vector perpendicular to u(j-1))   
	   call random_unit_vector(unit) 
	   scalar   = unit(1)*u(j-1,1)+unit(2)*u(j-1,2)+unit(3)*u(j-1,3)
	   ulen2=0.D0; do k=1,3; unit(k)=unit(k)-scalar*u(j-1,k); ulen2=ulen2+unit(k)**2; enddo     
	   ulen = dsqrt(ulen2); do k=1,3; unit(k)=unit(k)/ulen; enddo				    	! this way unit is a unit vector perpendicular to u(j-1)
	   ulen2 = 0.D0											! for numerical precision only
	   do k=1,3; u(j,k) = stheta(linet)*unit(k) + ctheta(linet)*u(j-1,k); ulen2 = ulen2 + u(j,k)**2; enddo 
	   ulen = dsqrt(ulen2)
	  else							! the usual case where u(j-2) and u(j-1) are not parallel to each other  
           prefactor = stheta(linet)/stheta_prev
           factor1   = ctheta(linet)
           factor2   = prefactor*cosphi(line)*ctheta_prev
           factor3   = prefactor*cosphi(line)
           factor4   = prefactor*sinphi(line)
           ulen2 = 0.D0
           do k=1,3
            ! u(j,k)=(1.D0+cosphi(line))*ctheta(linet)*u(j-1,k)-cosphi(line)*u(j-2,k)+sinphi(line)*cross(k)
	    u(j,k)= factor1*u(j-1,k) + factor2*u(j-1,k) - factor3*u(j-2,k) + factor4*cross(k)
            ulen2 = ulen2 + u(j,k)**2
           enddo
           ulen = dsqrt(ulen2)
	  endif
          do k=1,3; u(j,k)=u(j,k)/ulen; x(j,k)=x(j-1,k)+b*u(j,k); enddo
          if (overlap(x,j)) return 
          if (outside(x(j,1),x(j,2),x(j,3))) return
          if (mod(j,erpenbeck_s).eq.0) then
           do i=1,erpenbeck_f
            if (j.le.N) call quickwalk(x,u,j+1,created,tic,timeout)
           enddo
          else
           call quickwalk(x,u,j+1,created,tic,timeout)
          endif
         endif
        return
        end

	recursive subroutine linearwalk(x,u,j,jmax)       ! j-1 is known generate j
        implicit none
        integer chains,N
        include 'inc.N' ! defines N,chains
        real*8  u(N,3),x(0:N,3)
        integer resolution
        include 'inc.resolution'
        real*8  b,d,d2
        include 'inc.parameter'
        real*8 cross(3),ulen,ulen2
        real*8 cosphi(resolution),sinphi(resolution)
	real*8 ctheta(resolution),stheta(resolution)
        common /comcs/ cosphi, sinphi, ctheta, stheta
        integer id,chain,idbond
        common /comid/ id,chain,idbond
        integer outputformat
        real*8 fn(0:N)
        include 'inc.outputformat'
        real myrand2(2)
        integer line,linet,i,j,k,jmax
        logical overlap,outside
        external overlap,outside
        integer erpenbeck_s,erpenbeck_f
        common /erpenbeck_wall/ erpenbeck_s,erpenbeck_f
	real*8 unit(3),scalar
        real*8 tic,toc,timeout
	real*8 ctheta_prev,stheta_prev,prefactor,factor1,factor2,factor3,factor4
	 jmax = max(j,jmax)
         if (j.eq.N+1) then
          return
         else
          call random_number(myrand2)
          line =1+int(resolution*myrand2(1))
	  linet=1+int(resolution*myrand2(2))
          cross(1) = u(j-2,2)*u(j-1,3)-u(j-2,3)*u(j-1,2)
          cross(2) = u(j-2,3)*u(j-1,1)-u(j-2,1)*u(j-1,3)
          cross(3) = u(j-2,1)*u(j-1,2)-u(j-2,2)*u(j-1,1)
	  ctheta_prev = u(j-2,1)*u(j-1,1)+u(j-2,2)*u(j-1,2)+u(j-2,3)*u(j-1,3)
          stheta_prev = dsqrt(1.D0-ctheta_prev**2)
	  if (stheta_prev.lt.1.D-6) then                        ! exception for u(j-2) || u(j-1) (find a vector perpendicular to u(j-1))   
           call random_unit_vector(unit)
	   scalar   = unit(1)*u(j-1,1)+unit(2)*u(j-1,2)+unit(3)*u(j-1,3)
           ulen2=0.D0; do k=1,3; unit(k)=unit(k)-scalar*u(j-1,k); ulen2=ulen2+unit(k)**2; enddo
           ulen = dsqrt(ulen2); do k=1,3; unit(k)=unit(k)/ulen; enddo                                   ! this way unit is a unit vector perpendicular to u(j-1)
           ulen2 = 0.D0                                                                                 ! for numerical precision only
           do k=1,3; u(j,k) = stheta(linet)*unit(k) + ctheta(linet)*u(j-1,k); ulen2 = ulen2 + u(j,k)**2; enddo
           ulen = dsqrt(ulen2)
          else
           prefactor = stheta(linet)/stheta_prev
           factor1   = ctheta(linet)
           factor2   = prefactor*cosphi(line)*ctheta_prev
           factor3   = prefactor*cosphi(line)
           factor4   = prefactor*sinphi(line)
           ulen2 = 0.D0
           do k=1,3
            ! u(j,k)=(1.D0+cosphi(line))*ctheta(linet)*u(j-1,k)-cosphi(line)*u(j-2,k)+sinphi(line)*cross(k)
	    u(j,k)= factor1*u(j-1,k) + factor2*u(j-1,k) - factor3*u(j-2,k) + factor4*cross(k)
            ulen2 = ulen2 + u(j,k)**2
           enddo
           ulen = dsqrt(ulen2)
	  endif
	  do k=1,3; u(j,k)=u(j,k)/ulen; x(j,k)=x(j-1,k)+b*u(j,k); enddo
          if (overlap(x,j)) return
          if (outside(x(j,1),x(j,2),x(j,3))) return
          call linearwalk(x,u,j+1,jmax)
         endif
        return
        end

	recursive subroutine walk(x,u,j,created)		! j-1 is known generate j
	implicit none
	integer chains,N
        include 'inc.N' ! defines N,chains
	real*8  u(N,3),x(0:N,3)
	integer resolution
        include 'inc.resolution'
	real*8  b,d,d2
        include 'inc.parameter'
	real*8 cross(3),ulen,ulen2
        real*8 cosphi(resolution),sinphi(resolution)
	real*8 ctheta(resolution),stheta(resolution)
        common /comcs/ cosphi, sinphi, ctheta, stheta
	integer id,chain,idbond
	common /comid/ id,chain,idbond
	integer outputformat
        real*8 fn(0:N)
        include 'inc.outputformat'
	integer periodx,periody,periodz
        include 'inc.periodic' ! defines periodic
	real myrand2(2)
	integer line,linet,i,j,k
	integer i1,i2,in
	logical created
	logical overlap,outside
	external overlap,outside
	integer erpenbeck_s,erpenbeck_f
	common /erpenbeck_wall/ erpenbeck_s,erpenbeck_f
	integer max_s
	common /track_max_s/ max_s
	real*8 unit(3),scalar
	real*8 ctheta_prev,stheta_prev,prefactor,factor1,factor2,factor3,factor4
	integer dx,dy,dz
	real*8 xlo,xhi,ylo,yhi,zlo,zhi,boxx,boxy,boxz,ee2
        include 'inc.box'
	integer id1,id2,id3,type
	real*8  tmp
	real*8  average_ee,error_ee
	common /ave_ee/ average_ee,error_ee

	 created=.false.

 	 if (j.eq.N+1) then
	  ! save
	  if (x(N,1).ne.x(N,1)) return                          ! nan check
	  created=.true.
	  if (chain.eq.chains) return
	  chain=chain+1
	  ! call healthy_conformation_check(x)
	  select case (outputformat) 
	  case (1) 						! xyz
	   do i=0,N
	    id=id+1; write(11,111) (x(i,k),k=1,3)
	   enddo
	  case (2)						! dump
	   id=id+1; write(11,112) id,chain,1,(x(0,k),k=1,3)
 	   do i=1,N-1
            id=id+1; write(11,112) id,chain,2,(x(i,k),k=1,3)
	   enddo
	   id=id+1; write(11,112) id,chain,3,(x(N,k),k=1,3)
	  case (3) 						! Z1
 	   do i=0,N
            id=id+1; write(11,113) (x(i,k),k=1,3)
	   enddo 
	  case(4) 						! d3D
	   do i=0,N
	    id=id+1
	    if (periodx.eq.1) then				! px
	     tmp=x(i,1)-(xlo+xhi)/2.D0; tmp=tmp-anint(tmp/boxx)*boxx; id1=min(densMX,1+int(tmp+0.5*boxx))
	    else
	     id1=1+int(x(i,1)-xlo); id1=max(1,min(densMX,id1))
	    endif
	    if (periody.eq.1) then
	     tmp=x(i,2)-(ylo+yhi)/2.D0; tmp=tmp-anint(tmp/boxy)*boxy; id2=min(densMY,1+int(tmp+0.5*boxy))
            else
             id2=1+int(x(i,2)-ylo); id2=max(1,min(densMY,id2))
            endif
	    if (periodz.eq.1) then
	     tmp=x(i,3)-(zlo+zhi)/2.D0; tmp=tmp-anint(tmp/boxz)*boxz; id3=min(densMZ,1+int(tmp+0.5*boxz))
            else
             id3=1+int(x(i,3)-zlo); id3=max(1,min(densMZ,id3))
            endif
	    densHIST(id1,id2,id3)=densHIST(id1,id2,id3)+1 
	   enddo
	  case (5) 						! ee
	   write(11,111) (x(N,k)-x(0,k),k=1,3)
	  case (6) 						! mol2
	   do i=0,N  
	    id=id+1; write(11,602) id,'C',id,(x(i,k),k=1,3),'C','1','<0>','0.0'
	   enddo
	   do i=1,N
	    idbond=idbond+1; write(12,603) idbond,idbond+chain-1,idbond+chain,1
	   enddo
	  case (7) 						! fn
	   do i1=1,N
	    do i2=i1,N
	     in=i2-i1
	     fn(in)=fn(in)+u(i1,1)*u(i2,1)+u(i1,2)*u(i2,2)+u(i1,3)*u(i2,3)
	    enddo
	   enddo
	  case (8) 						! gro
	   do i=0,N
	    id=id+1; write(11,'(i5,2a5,i5,3f8.3,3f8.4)') chain,'POLYM','    C',id,(x(i,k),k=1,3),(0.0,k=1,3)
	   enddo
	  case (9) 						! pdb
	   ! https://people.ucalgary.ca/~tieleman/download.html
	   do i=0,N
	    id=id+1
	    write(11,'(A6,I5,1X,A4,1X,A3,1X,1X,I4,1X,3X,3F8.3,2F6.2,6X,4X,2X,2X)') '  ATOM',id,'   C','  C',chain,(x(i,k),k=1,3),0.0,0.0
	   enddo
	  end select
	  ee2 = (x(N,1)-x(0,1))**2+(x(N,2)-x(0,2))**2+(x(N,3)-x(0,3))**2; average_ee = average_ee + ee2; error_ee = error_ee + ee2**2
          include 'inc.format'
	  return
	 else
	  if (j.gt.max_s) then
	   max_s=j
	   if (mod(max_s,1000).eq.0) then
	    print 300,'max grown up to n = ',max_s,' s = ',erpenbeck_s,' f = ',erpenbeck_f
300	    format(A40,I6,A,I6,A,I2)
	   endif
	  endif
	  call random_number(myrand2)
          line =1+int(resolution*myrand2(1))
	  linet=1+int(resolution*myrand2(2))
          cross(1) = u(j-2,2)*u(j-1,3)-u(j-2,3)*u(j-1,2)
          cross(2) = u(j-2,3)*u(j-1,1)-u(j-2,1)*u(j-1,3)
          cross(3) = u(j-2,1)*u(j-1,2)-u(j-2,2)*u(j-1,1)
	  ctheta_prev = u(j-2,1)*u(j-1,1)+u(j-2,2)*u(j-1,2)+u(j-2,3)*u(j-1,3)
	  stheta_prev = dsqrt(1.D0-ctheta_prev**2)
	  if (stheta_prev.lt.1.D-6) then                        ! exception for u(j-2) || u(j-1) (find a vector perpendicular to u(j-1))   
           call random_unit_vector(unit)
           scalar   = unit(1)*u(j-1,1)+unit(2)*u(j-1,2)+unit(3)*u(j-1,3)
           do k=1,3; unit(k)=unit(k)-scalar*u(j-1,k); enddo     ! this way unit is perpendicular to u(j-1)
	   cross(1) = u(j-1,2)*unit(3)-u(j-1,3)*unit(2)
           cross(2) = u(j-1,3)*unit(1)-u(j-1,1)*unit(3)         ! this way cross is a unit vector as well
           cross(3) = u(j-1,1)*unit(2)-u(j-1,2)*unit(1)
           ulen2 = 0.D0
           do k=1,3
            u(j,k) = stheta(linet)*(cosphi(line)*unit(k)+sinphi(line)*cross(k)) + ctheta(linet)*u(j-1,k)
            ulen2 = ulen2 + u(j,k)**2
           enddo
	   ulen = dsqrt(ulen2)
          else
	   prefactor = stheta(linet)/stheta_prev
	   factor1   = ctheta(linet)
	   factor2   = prefactor*cosphi(line)*ctheta_prev
	   factor3   = prefactor*cosphi(line)
	   factor4   = prefactor*sinphi(line)
           ulen2 = 0.D0
           do k=1,3
            ! u(j,k)=(1.D0+cosphi(line))*ctheta(linet)*u(j-1,k)-cosphi(line)*u(j-2,k)+sinphi(line)*cross(k)
	    u(j,k)= factor1*u(j-1,k) + factor2*u(j-1,k) - factor3*u(j-2,k) + factor4*cross(k)
            ulen2 = ulen2 + u(j,k)**2
           enddo
           ulen = dsqrt(ulen2)
	  endif
          do k=1,3
           u(j,k)=u(j,k)/ulen
           x(j,k)=x(j-1,k)+b*u(j,k)
          enddo
          if (overlap(x,j)) then
           return ! print *,'overlap bead ',j
          endif
          if (outside(x(j,1),x(j,2),x(j,3))) then
           return ! print *,'outside bead ',j
          endif
	  if (mod(j,erpenbeck_s).eq.0) then
	   do i=1,erpenbeck_f
	    if (.not.created) call walk(x,u,j+1,created)
	   enddo
	  else
	   call walk(x,u,j+1,created)
	  endif
	 endif
	return
	end

 	function outside(x_,y_,z_)	
	implicit none
	logical outside
	real*8 x,y,z,x_,y_,z_
	integer periodx,periody,periodz
        include 'inc.periodic'
	real*8 xlo,xhi,ylo,yhi,zlo,zhi,boxx,boxy,boxz
        include 'inc.box'
	 x=x_; y=y_; z=z_
	 if (periodx.eq.1) then; x = x-(xlo+xhi)/2.D0; x = x - anint(x/boxx)*boxx; x = x + (xlo+xhi)/2.D0; endif ! fold (revised 25 nov 2023)
	 if (periody.eq.1) then; y = y-(ylo+yhi)/2.D0; y = y - anint(y/boxy)*boxy; y = y + (ylo+yhi)/2.D0; endif ! fold	(revised 25 nov 2023)
	 if (periodz.eq.1) then; z = z-(zlo+zhi)/2.D0; z = z - anint(z/boxz)*boxz; z = z + (zlo+zhi)/2.D0; endif ! fold (revised 25 nov 2023)
 	 include 'inc.outside'
	 if (outside) return
	 outside=.true.		
	 if (periodx.eq.0) then
	  if (x.gt.xhi) return
    	  if (x.lt.xlo) return
	 endif
	 if (periody.eq.0) then
	  if (y.gt.yhi) return
	  if (y.lt.ylo) return
	 endif
	 if (periodz.eq.0) then
	  if (z.gt.zhi) return
	  if (z.lt.zlo) return
	 endif
	 outside=.false.
	return
	end
	
	subroutine get_x012(anchor_x,anchor_u1,b,x,u)
	implicit none
	integer chains,N
        include 'inc.N' ! defines N,chains
        real*8  u(N,3),x(0:N,3),b
	integer resolution
	include 'inc.resolution'
	real*8 anchor_x(3),anchor_u1(3), unit(3), cross(3)
	real*8 lencross,x1(3),x2(3)
 	real*8 cosphi(resolution),sinphi(resolution)
        real*8 ctheta(resolution),stheta(resolution)
        common /comcs/ cosphi, sinphi, ctheta, stheta	
	real   myrand
	integer linet,j,k
	logical overlap3,outside3
	logical overlap,outside
	external overlap,outside
	 do k=1,3; u(1,k)=anchor_u1(k); enddo
	 do k=1,3; x(0,k)=anchor_x(k); enddo
	 do k=1,3; x(1,k)=x(0,k)+b*u(1,k); enddo
	 j=1
	 if (outside(x(j,1),x(j,2),x(j,3))) then
	  open(44,file='_code_error'); rewind(44)
	  write(44,'(A)') 'ERROR: first bond resides outside the confinement'
	  close(44)
          stop ! 'ERROR: first bond resides outside the confinement'
         endif
	 if (N.eq.1) return
	 overlap3=.true.; outside3=.true.
	 do while (overlap3.or.outside3) 
	  call random_number(myrand)
	  linet=1+int(resolution*myrand)
	  lencross = 0.D0
	  do while (lencross.lt.1.D-10) 
	   call random_unit_vector(unit)
	   cross(1) = anchor_u1(2)*unit(3)-anchor_u1(3)*unit(2) 
 	   cross(2) = anchor_u1(3)*unit(1)-anchor_u1(1)*unit(3)
	   cross(3) = anchor_u1(1)*unit(2)-anchor_u1(2)*unit(1)
	   lencross = dsqrt(cross(1)**2+cross(2)**2+cross(3)**2)
	  enddo
	  do k=1,3; cross(k)=cross(k)/lencross; enddo	
	  do k=1,3; u(2,k)=ctheta(linet)*u(1,k)+stheta(linet)*cross(k); enddo 	 
	  do k=1,3; x(2,k)=x(1,k)+b*u(2,k); enddo
	  j=2
          overlap3=.false.; if (overlap(x,j)) overlap3=.true.
          outside3=.false.; if (outside(x(j,1),x(j,2),x(j,3))) outside3=.true.
	 enddo
         ! call healthy_x012_check(x)
	return
	end

	subroutine random_unit_vector(vec)
        implicit none
        real*8 vec(3),z2,z(2)
        real myrand2(2)
        integer i
         z2=2.0
         do while (z2.gt.1.D0)
          call random_number(myrand2)
          z2=0.D0; do i=1,2; z(i) = 1.0 - 2.D0*myrand2(i); z2 = z2 + z(i)**2; end do
         enddo
         do i=1,2; vec(i)=2.D0*z(i)*dsqrt(1.-z2); end do
         vec(3)=1.D0-2.D0*z2
        return
        end

! --------------------------------------------------------------------------------- health check (not in use)

	subroutine healthy_x012_check(x)
	implicit none
        integer chains,N
        include 'inc.N' ! defines N,chains
        real*8  u(N,3),x(0:N,3)
        real*8  b,d,d2
        include 'inc.parameter'
        integer i,j,k
        real*8  ulen,dist(3),mindistance,distance
        integer periodx,periody,periodz
        include 'inc.periodic'
        real*8 xlo,xhi,ylo,yhi,zlo,zhi,boxx,boxy,boxz
        include 'inc.box'
        integer problem_pair1,problem_pair2
	include 'inc.skip'
         print *,'check healthy x012'
         problem_pair1 = 0; problem_pair2 = 0
         do i=1,2
          do k=1,3; dist(k) = x(i,k)-x(i-1,k); enddo
          dist(1)=dist(1)-anint(periodx*dist(1)/boxx)*boxx
          dist(2)=dist(2)-anint(periody*dist(2)/boxy)*boxy
          dist(3)=dist(3)-anint(periodz*dist(3)/boxz)*boxz
          ulen = dsqrt(dist(1)**2+dist(2)**2+dist(3)**2)
          if (abs(ulen-b).gt.0.01) then
           problem_pair1 = i-1
           problem_pair2 = i
           open(44,file='_code_error'); rewind(44)
           write(44,'(A)') 'ERROR healthy_x012_check bond length'
           write(44,'(A,2(I7,1x))') 'problem pair ',problem_pair1,problem_pair2
           close(44)
           stop 'health check (bondl) failed'
          endif
         enddo
         ! check minimum intramolecular distance
         mindistance = 1.D30
         problem_pair1 = 0; problem_pair2 = 0
         do i=0,2-1
         do j=i+1,2
          do k=1,3; dist(k) = x(i,k)-x(j,k); enddo
          dist(1)=dist(1)-anint(periodx*dist(1)/boxx)*boxx
          dist(2)=dist(2)-anint(periody*dist(2)/boxy)*boxy
          dist(3)=dist(3)-anint(periodz*dist(3)/boxz)*boxz
          distance = dsqrt(dist(1)**2+dist(2)**2+dist(3)**2)
          if (distance.lt.mindistance) then
           mindistance = distance
           problem_pair1 = i
           problem_pair2 = j
          endif
         enddo
         enddo
         if (skipmany.eq.0.and.mindistance.lt.0.999*d) then
          open(44,file='_code_error'); rewind(44)
          write(44,'(A)') 'ERROR healthy_x012_check intra distance'
          write(44,'(A,2(I7,1x))') 'problem pair ',problem_pair1,problem_pair2
          write(44,'(A,3(I1,1x))') 'at periodic ',periodx,periody,periodz
          write(44,'(A,6(F10.2,1x))') 'at lohi ',xlo,xhi,ylo,yhi,zlo,zhi
          write(44,'(2(A,F12.4))') 'problem distance ',mindistance,' < ',d
          write(44,'(A,3(F12.4,1x))') 'x1 ',(x(problem_pair1,k),k=1,3)
          write(44,'(A,3(F12.4,1x))') 'x2 ',(x(problem_pair2,k),k=1,3)
          close(44)
	  print *,'skipmany ',skipmany
          stop 'health check (diameter) failed'
         endif
        return
        end
	

        subroutine healthy_conformation_check(x)	! not in use
        implicit none
        integer chains,N
        include 'inc.N' ! defines N,chains
        real*8  u(N,3),x(0:N,3)
        real*8  b,d,d2
        include 'inc.parameter'
        integer i,j,k
        real*8  ulen,dist(3),mindistance,distance
        integer periodx,periody,periodz
        include 'inc.periodic'
        real*8 xlo,xhi,ylo,yhi,zlo,zhi,boxx,boxy,boxz
        include 'inc.box'
	integer problem_pair1,problem_pair2
	include 'inc.skip'
         print *,'check healthy conformation'
         ! check bond length
	 problem_pair1 = 0; problem_pair2 = 0
         do i=1,N
          do k=1,3; dist(k) = x(i,k)-x(i-1,k); enddo
          dist(1)=dist(1)-anint(periodx*dist(1)/boxx)*boxx
          dist(2)=dist(2)-anint(periody*dist(2)/boxy)*boxy
          dist(3)=dist(3)-anint(periodz*dist(3)/boxz)*boxz
          ulen = dsqrt(dist(1)**2+dist(2)**2+dist(3)**2)
          if (abs(ulen-b).gt.0.01) then
	   problem_pair1 = i-1
           problem_pair2 = i
	   open(44,file='_code_error'); rewind(44)
	   write(44,'(A)') 'ERROR healthy_conformation_check bond length'
	   write(44,'(A,2(I7,1x))') 'problem pair ',problem_pair1,problem_pair2
	   close(44)
	   stop 'health check (bondl) failed'
	  endif
         enddo
         ! check minimum intramolecular distance
         mindistance = 1.D30
	 problem_pair1 = 0; problem_pair2 = 0
         do i=0,N-1
         do j=i+1,N
          do k=1,3; dist(k) = x(i,k)-x(j,k); enddo
          dist(1)=dist(1)-anint(periodx*dist(1)/boxx)*boxx
          dist(2)=dist(2)-anint(periody*dist(2)/boxy)*boxy
          dist(3)=dist(3)-anint(periodz*dist(3)/boxz)*boxz
          distance = dsqrt(dist(1)**2+dist(2)**2+dist(3)**2)
          if (distance.lt.mindistance) then
           mindistance = distance
	   problem_pair1 = i
	   problem_pair2 = j
          endif
         enddo
         enddo
         if (skipmany.eq.0.and.mindistance.lt.0.999*d) then
	  open(44,file='_code_error'); rewind(44)
	  write(44,'(A)') 'ERROR healthy_conformation_check intra distance'
	  write(44,'(A,2(I7,1x))') 'problem pair ',problem_pair1,problem_pair2
	  write(44,'(A,3(I1,1x))') 'at periodic ',periodx,periody,periodz
	  write(44,'(A,6(F10.2,1x))') 'at lohi ',xlo,xhi,ylo,yhi,zlo,zhi
	  write(44,'(2(A,F12.4))') 'problem distance ',mindistance,' < ',d
	  write(44,'(A,3(F12.4,1x))') 'x1 ',(x(problem_pair1,k),k=1,3)
	  write(44,'(A,3(F12.4,1x))') 'x2 ',(x(problem_pair2,k),k=1,3)
	  close(44)
	  stop 'health check (diameter) failed'
	 endif
        return
        end


	subroutine erase_blank_from_string(A,Alen)
        implicit none
        character(len=*) :: A
        integer i,c,space,Alen
         c=0; space=0
         do i=1,len(A)
          if (A(i:i).ne.' ') then
           if (space.eq.1) then
            c=c+1; A(c:c)=' '
           endif
           c=c+1; A(c:c)=A(i:i); space=0
          else
           if (c.ne.0) space=1
          endif
         enddo
         do i=c+1,len(A); A(i:i)=' '; enddo
	 Alen=c
        return
        end

        subroutine ensure_unity(N,b_use,X,s)
        implicit none
        integer N,X,s,Y,mys,s_for_Y
        real*8 b_use,min_dev,dev,LOGLHS,LOGRHS
	real*8 firstLOGLHS,lastLOGLHS,firstLOGRHS,lastLOGRHS
	 min_dev = 1.D6
         do Y=1,20 	! must start from 1
          dev = 1.D6
          do mys=1,max(1,N-2) ! must start from 1
	   LOGRHS = b_use*mys
	   if (dble(N)/dble(mys).gt.3.D0) then
	    LOGLHS = (dble(N)/dble(mys))*dlog(dble(Y))
	   else
	    LOGLHS = dlog( Y**(dble(N)/dble(mys)+1.0) )
	   endif
	   if (mys.eq.1) then
 	    firstLOGLHS = LOGLHS
            firstLOGRHS = LOGRHS
	   else
	    lastLOGLHS = LOGLHS
            lastLOGRHS = LOGRHS
	   endif
	   print 999,'E-W testing X s LHS RHS',Y,mys,LOGLHS,LOGRHS
999	   format(A30,I3,1x,I3,1x,F10.3,1x,F10.3)
	   if (abs(LOGLHS-LOGRHS).lt.dev) then
	    dev = abs(LOGLHS-LOGRHS)
            s_for_Y = mys
	    if (dev.lt.min_dev) then
	     min_dev = dev
	     s = mys
	     X = Y 
	    endif
           endif
	  enddo
          print 104,'E-W suitable pair X s dev',Y,s_for_Y,dev
	  print 101,'E-W first ln(LHS) ln(RHS)',firstLOGLHS,firstLOGRHS
	  print 101,'E-W last  ln(LHS) ln(RHS)',lastLOGLHS,lastLOGRHS
          if (firstLOGLHS.gt.firstLOGRHS.and.lastLOGLHS.lt.lastLOGRHS) return	! crit
         enddo
100	format(A40,I10)
101	format(A40,2(F10.3,1x))
104     format(A40,2(I5,1x),F10.4)
        return
        end


        subroutine init_seed
        implicit none
        logical EX
        integer, allocatable :: oldseed(:)
        integer n
        inquire(file='.seed',EXIST=EX)
        call random_seed(size=n)
        allocate(oldseed(n))
        if (EX) then
         open(2,file='.seed'); rewind(2)
         read(2,*) oldseed
         close(2)
         call random_seed(put=oldseed)
        else
         call random_seed()
        endif
        return
        end

        subroutine finalize_seed
        integer, allocatable :: oldseed(:)
        integer n
        call random_seed(size=n)
        allocate(oldseed(n))
         call random_seed(get=oldseed)
         open(2,file='.seed'); rewind(2)
         write(2,*) oldseed
         close(2)
        return
        end
	
	include 'inc.overlap-used'
	include 'INSTDIR/inc.tictoc'
